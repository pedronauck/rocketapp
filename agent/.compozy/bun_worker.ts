#!/usr/bin/env bun
// @ts-ignore
// .compozy/bun_worker.ts
// Generated by Compozy - DO NOT EDIT

// Import all tools from entrypoint
import fs from "node:fs/promises";
import os from "node:os";
import path from "node:path";
import * as allExports from "../entrypoint.ts";

// Configuration constants
const DEFAULT_TIMEOUT_MS = 60000;
const MAX_HEAP_SNAPSHOTS_TO_KEEP = 5;

// Check if debugging is enabled
const DEBUG_MODE = process.env.COMPOZY_DEBUG === "true";
const HEAP_PROFILING = process.env.COMPOZY_HEAP_PROFILING === "true";

interface Request {
  tool_id: string;
  tool_exec_id: string;
  input: any;
  config?: any;
  env: Record<string, string>;
  timeout_ms?: number;
}

interface Response {
  result: any;
  error: ErrorInfo | null;
  metadata?: {
    tool_id: string;
    tool_exec_id: string;
    execution_time?: number;
  };
}

interface ErrorInfo {
  message: string;
  stack?: string;
  name: string;
  tool_id: string;
  tool_exec_id: string;
  timestamp: string;
}

// Redirect all console output methods to stderr to prevent stdout pollution
// This ensures that tool console calls don't interfere with JSON response parsing
// In DEBUG_MODE, still redirect but with distinguishable prefixes

// Store the original console.error to use for redirecting other methods
const originalError = console.error;

/**
 * Redirects common console methods to stderr and prefixes each message with an optional debug context.
 *
 * Replaces console.log/debug/info/warn/error so they all forward their arguments to the preserved
 * stderr writer (via `originalError`) with a prefix. If `debugPrefix` is provided it is included
 * in square brackets before the method name (e.g. `[MY_PREFIX][ERROR]`); otherwise only the
 * method name is used (e.g. `[ERROR]`).
 *
 * Side effects:
 * - Mutates the global `console` object by overwriting the listed methods.
 *
 * @param debugPrefix - Optional identifier used as a per-run debug prefix included in each message.
 */
function redirectConsole(debugPrefix = ""): void {
  const methods: (keyof Console)[] = ["log", "debug", "info", "warn", "error"];
  for (const method of methods) {
    const prefix = debugPrefix
      ? `[${debugPrefix}][${method.toUpperCase()}]`
      : `[${method.toUpperCase()}]`;
    console[method] = (...args: unknown[]): void => {
      originalError(prefix, ...args);
    };
  }
}

// Apply console redirection based on debug mode
redirectConsole(DEBUG_MODE ? "DEBUG" : "");

/**
 * Validate that a tool identifier is safe and well-formed.
 *
 * Returns true if `toolId` contains only letters, digits, underscores, slashes, dots, or dashes,
 * and does not contain directory traversal segments (`".."`) or start with a leading slash.
 *
 * @param toolId - The tool identifier to validate.
 * @returns `true` when `toolId` is allowed; otherwise `false`.
 */
function isValidToolId(toolId: string): boolean {
  const validPattern = /^[a-zA-Z0-9_/.-]+$/;
  if (!validPattern.test(toolId)) return false;
  if (toolId.includes("..") || toolId.startsWith("/")) return false;
  return true;
}

/**
 * Executes an asynchronous tool function and rejects if it does not complete within the given timeout.
 *
 * Runs `fn(input, config)` and returns its resolved value. If execution exceeds `timeoutMs`, the returned promise rejects with an Error whose message indicates the timeout. Any error thrown by `fn` is propagated.
 *
 * @param fn - Asynchronous function to execute; receives `input` and optional `config`.
 * @param input - Input passed to `fn`.
 * @param config - Optional configuration passed to `fn`.
 * @param timeoutMs - Maximum allowed execution time in milliseconds before rejecting with a timeout error.
 * @returns A promise that resolves with `fn`'s result or rejects with the original error or a timeout Error.
 */
async function executeWithTimeout(
  fn: (input: any, config?: any) => Promise<any>,
  input: any,
  config: any,
  timeoutMs: number
): Promise<any> {
  return new Promise((resolve, reject) => {
    const timeoutId = setTimeout(
      () => reject(new Error(`Tool execution timed out after ${timeoutMs}ms`)),
      timeoutMs
    );

    Promise.resolve(fn(input, config))
      .then(result => {
        clearTimeout(timeoutId);
        resolve(result);
      })
      .catch(err => {
        clearTimeout(timeoutId);
        reject(err);
      });
  });
}

/**
 * Capture a process-scoped heap snapshot (if available) and prune older snapshots.
 *
 * Creates a secure, per-process temporary directory, writes a heap snapshot file whose
 * name includes a sanitized `toolId`, verifies the resolved path is contained in the
 * snapshot directory, and then removes older `.heapsnapshot` files to keep disk usage
 * bounded. All errors are logged and do not propagate.
 *
 * @param toolId - Identifier incorporated into the snapshot filename; characters unsafe for filenames are replaced with `_`.
 * @returns A promise that resolves when snapshot capture and cleanup complete.
 */
async function captureAndCleanupHeapSnapshot(toolId: string): Promise<void> {
  try {
    // Create a dedicated, process-specific directory for heap snapshots
    const SNAPSHOT_DIR = path.join(os.tmpdir(), `compozy-heap-snapshots-${process.pid}`);

    // Ensure directory exists with secure permissions
    await fs.mkdir(SNAPSHOT_DIR, { recursive: true, mode: 0o700 });

    // Generate snapshot with secure path
    const snapshotName = `heap-${toolId.replace(/[^a-zA-Z0-9-]/g, "_")}-${Date.now()}.heapsnapshot`;
    const snapshotPath = path.join(SNAPSHOT_DIR, snapshotName);

    // Validate that the resolved path is within our directory
    const resolvedPath = path.resolve(snapshotPath);
    const resolvedDir = path.resolve(SNAPSHOT_DIR);
    if (!resolvedPath.startsWith(resolvedDir)) {
      throw new Error("Security: Invalid snapshot path detected");
    }

    // Write the heap snapshot
    await Bun.writeHeapSnapshot(snapshotPath);
    originalError(`Heap snapshot written to ${snapshotPath}`);

    // Clean up old snapshots from our dedicated directory
    await cleanupOldSnapshots(SNAPSHOT_DIR);
  } catch (error) {
    originalError("Failed to capture or cleanup heap snapshot:", error);
  }
}

/**
 * Remove old `.heapsnapshot` files from a dedicated snapshot directory, keeping only the most recent snapshots.
 *
 * Scans the given directory for files ending with `.heapsnapshot`, sorts them by modification time (newest first),
 * and deletes snapshots beyond the retention limit defined by `MAX_HEAP_SNAPSHOTS_TO_KEEP`.
 * The function treats concurrently-removed files as non-fatal and logs other I/O errors without throwing.
 *
 * @param snapshotDir - Path to the directory that contains heap snapshot files to prune.
 * @returns A promise that resolves once cleanup is complete.
 */
async function cleanupOldSnapshots(snapshotDir: string): Promise<void> {
  try {
    // Read only our dedicated directory (not entire /tmp)
    const entries = await fs.readdir(snapshotDir, { withFileTypes: true });

    // Filter and map snapshots with stats in parallel
    const snapshotPromises = entries
      .filter(entry => entry.isFile() && entry.name.endsWith(".heapsnapshot"))
      .map(async entry => {
        try {
          const filePath = path.join(snapshotDir, entry.name);
          const stats = await fs.stat(filePath);
          return {
            name: entry.name,
            path: filePath,
            time: stats.mtime.getTime(),
          };
        } catch {
          // File may have been deleted by another process
          return null;
        }
      });

    // Wait for all stat operations
    const snapshots = (await Promise.all(snapshotPromises)).filter(
      (s): s is NonNullable<typeof s> => s !== null
    );

    // Sort by modification time, newest first
    snapshots.sort((a, b) => b.time - a.time);

    // Remove old snapshots beyond the retention limit
    const snapshotsToDelete = snapshots.slice(MAX_HEAP_SNAPSHOTS_TO_KEEP);

    // Delete old snapshots with proper error handling
    for (const snapshot of snapshotsToDelete) {
      try {
        await fs.unlink(snapshot.path);
        originalError(`Cleaned up old heap snapshot: ${snapshot.name}`);
      } catch (error: any) {
        // Ignore ENOENT errors (file already deleted)
        if (error?.code !== "ENOENT") {
          originalError(`Failed to cleanup snapshot ${snapshot.name}:`, error);
        }
      }
    }
  } catch (error) {
    originalError("Failed to cleanup old heap snapshots:", error);
  }
}

// Set memory limit from environment if available
if (process.env.COMPOZY_MAX_MEMORY_MB) {
  const maxMemoryMB = parseInt(process.env.COMPOZY_MAX_MEMORY_MB, 10);

  // Validate the parsed value
  if (isNaN(maxMemoryMB) || maxMemoryMB <= 0) {
    const error = new Error(
      `Invalid COMPOZY_MAX_MEMORY_MB value: "${process.env.COMPOZY_MAX_MEMORY_MB}". ` +
        `Expected a positive integer representing megabytes.`
    );
    originalError("[CRITICAL] Memory limit configuration error:", error.message);
    // Fail fast on invalid configuration
    process.exit(1);
  }

  if (typeof process.setResourceLimits === "function") {
    try {
      // Set memory limits if supported by runtime
      process.setResourceLimits({ maxHeapSize: maxMemoryMB });
      originalError(`[INFO] Memory limit set to ${maxMemoryMB}MB`);
    } catch (err) {
      // Log with structured format and context
      const error = err instanceof Error ? err : new Error(String(err));
      originalError("[CRITICAL] Failed to set memory limit:", {
        error: error.message,
        stack: error.stack,
        requestedLimit: maxMemoryMB,
        env: process.env.COMPOZY_MAX_MEMORY_MB,
      });
      // Fail fast - memory limits are critical for preventing OOM
      process.exit(1);
    }
  } else {
    originalError("[WARNING] process.setResourceLimits not available in this runtime");
  }
}

/**
 * Orchestrates the worker lifecycle: reads a JSON Request from stdin, executes the requested tool, and writes a JSON Response to stdout.
 *
 * The function:
 * - Reads and parses stdin into a Request.
 * - Validates `tool_id` and applies a validated set of environment variable overrides (restored in finally).
 * - Resolves a tool function from the loaded entrypoint exports (supports default-exported object or named exports).
 * - Executes the tool with a configurable timeout and returns a structured Response containing `result`, `error`, and optional `metadata` (including execution_time).
 * - On parse/validation failures or other unrecoverable startup errors it writes an error Response and exits the process with code 1.
 * - On runtime errors it optionally captures a heap snapshot (when heap profiling is enabled and supported) and returns an error Response.
 *
 * Side effects:
 * - Mutates process.env temporarily while executing the tool (original environment is restored on completion).
 * - Writes responses to stdout and diagnostic logs to stderr.
 * - May call process.exit(1) for fatal startup errors (e.g., cannot read stdin or invalid JSON input).
 *
 * @returns A promise that resolves when execution and cleanup complete.
 */
async function main() {
  let inputText = "";

  try {
    // Read input from stdin using Bun's text() method
    inputText = await Bun.stdin.text();
  } catch (err) {
    originalError("Failed to read from stdin:", err);
    process.exit(1);
  }

  let req: Request;
  try {
    req = JSON.parse(inputText.trim());
  } catch (err) {
    originalError("Failed to parse JSON input:", err);
    const errorResponse: Response = {
      result: null,
      error: {
        message: "Invalid JSON input",
        name: "ParseError",
        tool_id: "",
        tool_exec_id: "",
        timestamp: new Date().toISOString(),
      },
    };
    process.stdout.write(JSON.stringify(errorResponse));
    process.exit(1);
  }

  const { tool_id, tool_exec_id, input, config, env, timeout_ms } = req;

  // Validate tool_id
  if (!tool_id || typeof tool_id !== "string" || !isValidToolId(tool_id)) {
    const errorResponse: Response = {
      result: null,
      error: {
        message: "Invalid tool_id: must be a non-empty string without directory traversal",
        name: "ValidationError",
        tool_id: tool_id || "",
        tool_exec_id: tool_exec_id || "",
        timestamp: new Date().toISOString(),
      },
    };
    process.stdout.write(JSON.stringify(errorResponse));
    process.exit(1);
  }

  // Store and set environment variables with validation
  const originalEnv = { ...process.env };
  const addedEnvKeys = new Set<string>();
  if (env && typeof env === "object") {
    for (const [key, value] of Object.entries(env)) {
      if (typeof key === "string" && typeof value === "string") {
        // Validate environment variable name (uppercase alphanumeric and underscore only)
        if (!/^[A-Z0-9_]+$/.test(key)) {
          throw new Error(`Invalid environment variable name: ${key}`);
        }

        // Validate value - prevent newlines and null bytes
        if (value.includes("\n") || value.includes("\r") || value.includes("\0")) {
          throw new Error(`Environment variable ${key} contains invalid characters`);
        }

        // Check for dangerous environment variables
        const dangerousVars = [
          "LD_PRELOAD",
          "LD_LIBRARY_PATH",
          "DYLD_INSERT_LIBRARIES",
          "DYLD_LIBRARY_PATH",
          "NODE_OPTIONS",
          "BUN_CONFIG_PROFILE",
        ];
        if (dangerousVars.includes(key)) {
          throw new Error(`Environment variable ${key} is not allowed for security reasons`);
        }

        if (!(key in originalEnv)) addedEnvKeys.add(key);
        process.env[key] = value;
      }
    }
  }

  const startTime = Date.now();

  try {
    // Support both export patterns:
    // 1. Default export: export default { "tool_name": toolFunction }
    // 2. Named exports: export const tool_name = toolFunction
    let tools: Record<string, any> = {};

    // Check if there's a default export (new standard)
    if (allExports.default && typeof allExports.default === "object") {
      tools = allExports.default;
    } else {
      // Use named exports (legacy pattern) - exclude 'default' key
      const { default: _, ...namedExports } = allExports;
      tools = namedExports;
    }

    const toolFn = tools[tool_id];
    if (typeof toolFn !== "function") {
      const availableTools = Object.keys(tools).filter(key => typeof tools[key] === "function");
      throw new Error(
        `Tool ${tool_id} not found in entrypoint exports. ` +
          `Available tools: ${availableTools.join(", ") || "none"}`
      );
    }

    // Execute tool with configurable timeout
    const timeoutMs = timeout_ms || DEFAULT_TIMEOUT_MS;
    const result = await executeWithTimeout(toolFn, input, config, timeoutMs);

    // Send success response
    const response: Response = {
      result,
      error: null,
      metadata: {
        tool_id,
        tool_exec_id,
        execution_time: Date.now() - startTime,
      },
    };
    process.stdout.write(JSON.stringify(response));
  } catch (err) {
    // Optional heap profiling on error for memory debugging
    if (
      HEAP_PROFILING &&
      typeof Bun !== "undefined" &&
      typeof Bun.writeHeapSnapshot === "function"
    ) {
      await captureAndCleanupHeapSnapshot(tool_id);
    }

    // Send error response
    const errorInfo: ErrorInfo = {
      message: err instanceof Error ? err.message : String(err),
      stack: err instanceof Error ? err.stack : undefined,
      name: err instanceof Error ? err.name : "UnknownError",
      tool_id,
      tool_exec_id,
      timestamp: new Date().toISOString(),
    };

    const response: Response = {
      result: null,
      error: errorInfo,
    };
    process.stdout.write(JSON.stringify(response));
  } finally {
    // Clean up environment variables
    try {
      for (const key of addedEnvKeys) {
        delete process.env[key];
      }
      for (const [key, value] of Object.entries(originalEnv)) {
        if (!addedEnvKeys.has(key) && process.env[key] !== value) {
          process.env[key] = value;
        }
      }
    } catch (cleanupErr) {
      originalError("Error during environment cleanup:", cleanupErr);
    }
  }
}

// Run main
main().catch(err => {
  originalError("Fatal error:", err);
  process.exit(1);
});
